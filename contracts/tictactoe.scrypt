import "util.scrypt";

contract TicTacToe {
    PubKey alice;
    PubKey bob;
    int deadline;

    static const int TURNLEN = 1;
    static const int BOARDLEN = 9;
    static const bytes EMPTY = b'00';
    static const bytes ALICE = b'01';
    static const bytes BOB = b'02';

    public function move(Sig sig, int amount, SigHashPreimage txPreimage, bytes sol) {
        require(Tx.checkPreimage(txPreimage));


        int who = unpack(sol[0: TURNLEN]);
        bytes board = sol[1 : ];
        require(len(board) == BOARDLEN);

        bytes play = who == 0 ? ALICE : BOB;

        PubKey player = who == 0 ? this.alice : this.bob;
        PubKey playerOther = who == 0 ?  this.bob : this.alice;
        // ensure it's player's turn
        require(checkSig(sig, player));


        bytes outputs = b'';
        if (this.won(board, play)) {
            // winner takes all
            //require(checkSig(sigother, playerOther));
            bytes outputScript = Util.pubKeyToP2PKH(player);
            bytes output = Util.buildOutput(outputScript, amount);
            outputs = output;
        }
        else if (this.full(board)) {
            // draw: equally split, i.e., both outputs have the same amount
            bytes aliceScript = Util.pubKeyToP2PKH(this.alice);
            bytes aliceOutput = Util.buildOutput(aliceScript, amount);

            bytes bobScript = Util.pubKeyToP2PKH(this.bob);
            bytes bobOutput = Util.buildOutput(bobScript, amount);

            outputs = aliceOutput + bobOutput;
        } else {
            require(Util.nLocktime(txPreimage) >= this.deadline);
            require(Util.nSequence(txPreimage) < 0xFFFFFFFF);
            // update state: next who & next board
            bytes scriptCode = Util.scriptCode(txPreimage);
            bytes output = Util.buildOutput(scriptCode, amount);
            outputs = output;
        }

        require(hash256(outputs) == Util.hashOutputs(txPreimage));
    }

    // does play win after current move?
    function won(bytes board, bytes play) : bool {
        // three in a row, a column, or a diagnoal
        int[8][3] lines = [
        [0, 1, 2],
        [3, 4, 5],
        [6, 7, 8],
        [0, 3, 6],
        [1, 4, 7],
        [2, 5, 8],
        [0, 4, 8],
        [2, 4, 6]
        ];

        bool anyLine = false;
        loop (8) : i {
            bool line = true;
            loop (3) : j {
                line = line && Util.getElemAt(board, lines[i][j]) == play;
            }

            anyLine = anyLine || line;
        }

        return anyLine;
    }

    // is board full?
    function full(bytes board) : bool {
        bool full = true;

        loop (BOARDLEN) : i {
            full = full && Util.getElemAt(board, i) != EMPTY;
        }

        return full;
    }

//     // withdraw after bidding is over
//     public function close(SigHashPreimage txPreimage, int amount) {
//         require(Tx.checkPreimage(txPreimage));
//         require(Util.nLocktime(txPreimage) >= this.deadline);
//         require(Util.nSequence(txPreimage) < 0xFFFFFFFF);

//         bytes aliceScript = Util.pubKeyToP2PKH(this.alice);
//         bytes aliceOutput = Util.buildOutput(aliceScript, amount);
//         bytes bobScript = Util.pubKeyToP2PKH(this.bob);
//         bytes bobOutput = Util.buildOutput(bobScript, amount);
//         bytes outputs = aliceOutput + bobOutput;

//         require(hash256(outputs) == Util.hashOutputs(txPreimage));
//     }
}